#include <stdio.h>

#include "types.h"
#include "tokenizer.h"
#include "object.h"

// #define _65C02

#define ____ 0x22 // Illegal opcode, used as placeholder for missing opcodes

const char *mnemonics[] = {
    "ADC", "AND", "ASL", "BCC", "BCS", "BEQ", "BIT", "BMI", "BNE", "BPL", "BRK", "BVC", "BVS", "CLC", "CLD",
    "CLI", "CLV", "CMP", "CPX", "CPY", "DEC", "DEX", "DEY", "EOR", "INC", "INX", "INY", "JMP", "JSR", "LDA",
    "LDX", "LDY", "LSR", "NOP", "ORA", "PHA", "PHP", "PLA", "PLP", "ROL", "ROR", "RTI", "RTS", "SBC", "SEC",
    "SED", "SEI", "STA", "STX", "STY", "TAX", "TAY", "TSX", "TXA", "TXS", "TYA", 0,
    // #ifdef _65C02
    //     "BRA",
    // #endif
};

const byte opcodes[][13] = {
    {____, 0x6D, 0x7D, 0x79, 0x69, ____, ____, 0x61, 0x71, ____, 0x65, 0x75, ____},
    {____, 0x2D, 0x3D, 0x39, 0x29, ____, ____, 0x21, 0x31, ____, 0x25, 0x35, ____},
    {0x0A, 0x0E, 0x1E, ____, ____, ____, ____, ____, ____, ____, 0x06, 0x16, ____},
    {____, ____, ____, ____, ____, ____, ____, ____, ____, 0x90, ____, ____, ____},
    {____, ____, ____, ____, ____, ____, ____, ____, ____, 0xB0, ____, ____, ____},
    {____, ____, ____, ____, ____, ____, ____, ____, ____, 0xF0, ____, ____, ____},
    {____, 0x2C, ____, ____, ____, ____, ____, ____, ____, ____, 0x24, ____, ____},
    {____, ____, ____, ____, ____, ____, ____, ____, ____, 0x30, ____, ____, ____},
    {____, ____, ____, ____, ____, ____, ____, ____, ____, 0xD0, ____, ____, ____},
    {____, ____, ____, ____, ____, ____, ____, ____, ____, 0x10, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x00, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, ____, ____, ____, ____, 0x50, ____, ____, ____},
    {____, ____, ____, ____, ____, ____, ____, ____, ____, 0x70, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x18, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0xD8, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x58, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0xB8, ____, ____, ____, ____, ____, ____, ____},
    {____, 0xCD, 0xDD, 0xD9, 0xC9, ____, ____, 0xC1, 0xD1, ____, 0xC5, 0xD5, ____},
    {____, 0xEC, ____, ____, 0xE0, ____, ____, ____, ____, ____, 0xE4, ____, ____},
    {____, 0xCC, ____, ____, 0xC0, ____, ____, ____, ____, ____, 0xC4, ____, ____},
    {____, 0xCE, 0xDE, ____, ____, ____, ____, ____, ____, ____, 0xC6, 0xD6, ____},
    {____, ____, ____, ____, ____, 0xCA, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x88, ____, ____, ____, ____, ____, ____, ____},
    {____, 0x4D, 0x5D, 0x59, 0x49, ____, ____, 0x41, 0x51, ____, 0x45, 0x55, ____},
    {____, 0xEE, 0xFE, ____, ____, ____, ____, ____, ____, ____, 0xE6, 0xF6, ____},
    {____, ____, ____, ____, ____, 0xE8, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0xC8, ____, ____, ____, ____, ____, ____, ____},
    {____, 0x4C, ____, ____, ____, ____, 0x6C, ____, ____, ____, ____, ____, ____},
    {____, 0x20, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____},
    {____, 0xAD, 0xBD, 0xB9, 0xA9, ____, ____, 0xA1, 0xB1, ____, 0xA5, 0xB5, ____},
    {____, 0xAE, ____, 0xBE, 0xA2, ____, ____, ____, ____, ____, 0xA6, ____, 0xB6},
    {____, 0xAC, 0xBC, ____, 0xA0, ____, ____, ____, ____, ____, 0xA4, 0xB4, ____},
    {0x4A, 0x4E, 0x5E, ____, ____, ____, ____, ____, ____, ____, 0x46, 0x56, ____},
    {____, ____, ____, ____, ____, 0xEA, ____, ____, ____, ____, ____, ____, ____},
    {____, 0x0D, 0x1D, 0x19, 0x09, ____, ____, 0x01, 0x11, ____, 0x05, 0x15, ____},
    {____, ____, ____, ____, ____, 0x48, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x68, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x28, ____, ____, ____, ____, ____, ____, ____},
    {0x2A, 0x2E, 0x3E, ____, ____, ____, ____, ____, ____, ____, 0x26, 0x36, ____},
    {0x6A, 0x6E, 0x7E, ____, ____, ____, ____, ____, ____, ____, 0x66, 0x76, ____},
    {____, ____, ____, ____, ____, 0x40, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x60, ____, ____, ____, ____, ____, ____, ____},
    {____, 0xED, 0xFD, 0xF9, 0xE9, ____, ____, 0xE1, 0xF1, ____, 0xE5, 0xF5, ____},
    {____, ____, ____, ____, ____, 0x38, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0xF8, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x78, ____, ____, ____, ____, ____, ____, ____},
    {____, 0x8D, 0x9D, 0x99, ____, ____, ____, 0x81, 0x91, ____, 0x85, 0x95, ____},
    {____, 0x8E, ____, ____, ____, ____, ____, ____, ____, ____, 0x86, ____, 0x96},
    {____, 0x8C, ____, ____, ____, ____, ____, ____, ____, ____, 0x84, 0x94, ____},
    {____, ____, ____, ____, ____, 0xAA, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0xA8, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0xBA, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x8A, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x9A, ____, ____, ____, ____, ____, ____, ____},
    {____, ____, ____, ____, ____, 0x98, ____, ____, ____, ____, ____, ____, ____},
};

instr_t instructions[2048];
short iIndex = 0;

int main() {
    const char *s =
        ".org $1234\nstart:  PHA\nagain:  LDA #42\n        DEC\n        BNE again\n        PLA\n        RTS";
    token_t token;
    byte mnemIndex;
    byte mode;
    instr_t *instr;
    while ((s = tokenize(s, mnemonics, &token))) {
        printf("%s: %s\n", token_kind_name(token.kind), token.data);
        if (token.kind == TOK_MNEMONIC) {
            mnemIndex = token.index;
            instr = &instructions[iIndex];
            // TODO: Detect addressing mode by fetching operands

            s = tokenize(s, mnemonics, &token);
            if (!s) {
                return 0;
            }
            if (token.kind == TOK_EOL) {
                // Implied
                mode = M_IMPL;
            } else if (token.kind == TOK_REGISTER) {
                // Accumulator
                mode = M_ACC;
            } else if (token.kind == TOK_LPAREN) {
                // One of indirect modes
            } else if (token.kind == TOK_HASH) {
                // Immediate
            }

            // instr->opcode = opcodes[token.index][1];
            // printf("Op: %d -> %d\n", token.index, instr->opcode);
            // printf("  - %d\n", token.index);
        }
    }
    return 0;
}
